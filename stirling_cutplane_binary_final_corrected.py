import numpy as npimport matplotlib.pyplot as pltfrom scipy.interpolate import interp1dimport mathdef stirling_log_factorial(n):    if n == 0 or n == 1:        return 0    return 0.5 * np.log(2 * np.pi * n) + n * np.log(n) - ndef compute_waiting_time(s, lam, mu):    rho = lam / (s * mu)    if rho >= 1:        return float('inf')    a = lam / mu    log_terms = np.array([n * np.log(a) - stirling_log_factorial(n) for n in range(s)])    sum_terms = np.sum(np.exp(log_terms))    last_term = np.exp(s * np.log(a) - stirling_log_factorial(s)) * (1 / (1 - rho))    P0 = 1 / (sum_terms + last_term)    Pw = (a ** s) / math.exp(stirling_log_factorial(s)) * P0 / (1 - rho)    Lq = Pw * rho / (1 - rho)    Wq = Lq / lam    return Wq  # already in minutesdef generate_s_star_curve(mu, target_wq, rho0_range):    s_star_vals = []    for rho0 in rho0_range:        lam = rho0 * mu        s = 1        while True:            Wq = compute_waiting_time(s, lam, mu)            if Wq <= target_wq:                break            s += 1        s_star_vals.append(s)    return s_star_valsdef binary_search_with_cut(lam, mu, target_wq, pwl_cut):    rho0 = lam / mu    s_min = math.ceil(pwl_cut(rho0))    s_max = 150    best = None    while s_min <= s_max:        mid = (s_min + s_max) // 2        Wq = compute_waiting_time(mid, lam, mu)        if Wq <= target_wq:            best = mid            s_max = mid - 1        else:            s_min = mid + 1    return best# Main parametersmu = 1 / 15target_wq = 10lam = 100 / 60# Generate s*(rho_0) cut-plane curverho0_range = np.linspace(20, 30, 40)s_star_vals = generate_s_star_curve(mu, target_wq, rho0_range)pwl_cut = interp1d(rho0_range, s_star_vals, kind='linear', fill_value="extrapolate")# Plottingplt.figure()plt.plot(rho0_range, s_star_vals, marker='o', color='orange')plt.xlabel(r"Offered Load $\lambda / \mu$")plt.ylabel(r"Minimum Required Servers $s^*(\rho_0)$")plt.title(r"Cut-Plane Curve Based on $\rho_0$")plt.grid(True)plt.savefig("cutplane_final_plot_corrected.png")plt.close()# Run binary search with cutoptimal_s = binary_search_with_cut(lam, mu, target_wq, pwl_cut)print(f"âœ… Final optimal number of servers (cut-plane + binary, corrected): {optimal_s}")